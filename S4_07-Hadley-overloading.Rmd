---
title: "R Notebook"
output: html_notebook
---

In this section we look at another example, and we examine some of the functions
associated with S4 classes. The example we define will be used to motivate the
use of methods associated with a class, and it will be used to demonstrate
inheritance later. The idea is that we want to create a program to simulate a
cellular automata model of a predator-prey system.

We do not develop the whole code here but concentrate on the data structures. In
particular we will create a base class for the agents. In the next section we
will create the basic methods for the class. In the inheritance section we will
discuss how to build on the class to create different predators and different
prey species. The basic structure of the class is shown in Figure 1.

The methods for this class are defined in the following section. Here we define
the class and its slots, and the code to define the class is given below:

```{r}
######################################################################
# Create the base Agent class
#
# This is used to represent the most basic agent in a simulation.
Agent <- setClass(
        # Set the name for the class
        "Agent",

        # Define the slots
        slots = c(
                location = "numeric",
                velocity   = "numeric",
                active   = "logical"
                ),

        # Set the default values for the slots. (optional)
        prototype = list(
                location = c(0.0,0.0),
                active   = TRUE,
                velocity = c(0.0,0.0)
                ),

        # Make a function that can test to see if the data is consistent.
        # This is not called if you have an initialize function defined!
        validity = function(object) {
                if(sum(object@velocity^2)>100.0) {
                        return("The velocity level is out of bounds.")
                }
                return(TRUE)
        })
```

Now that the code to define the class is given we can create an object whose class is Agent.


```{r}
a <- Agent()
a
```

Before we define the methods for the class a number of additional commands are
explored. The first set of functions explored are the `is.object` and the `isS4`
commands. The `is.object` command determines whether or not a variable refers to
an object. The `isS4` command determines whether or not the variable is an S4
object. The reason both are required is that the isS4 command alone cannot
determine if a variable is an S3 object. You need to determine if the variable
is an object and then decide if it is S4 or not.

```{r}
is.object(a)
isS4(a)
```

The next set of commands are used to get information about the data elements, or
slots, within an object. The first is the `slotNames` command. This command can
take either an object or the name of a class. It returns the names of the slots
associated with the class as strings.

```{r}
slotNames(a)
slotNames("Agent")
```

The `getSlots` command is similar to the `slotNames` command. It takes the name of a
class as a string. It returns a vector whose entries are the types associated
with the slots, and the names of the entries are the names of the slots.

```{r}
getSlots("Agent")
s <- getSlots("Agent")
s[1]
s[[1]]
names(s)
```

The next command examined is the `getClass` command. It has two forms. If you give
it a variable that is an S4 class it returns a list of slots for the class
associated with the variable. If you give it a character string with the name of
a class it gives the slots and their data types.

```{r}
getClass(a)
getClass("Agent")
```

The final command examined is the `slot command`. It can be used to get or set the
value of a slot in an object. It can be used in place of the “@” operator.

```{r}
slot(a,"location")              # get the value of location
slot(a, "location") <- c(1, 5)  # set the value in location
a
```

## 2.3. Creating Methods
We now build on the Agent class defined above. Once the class and its data
elements are defined we can define the methods associated with the class. The
basic idea is that if the name of a function has not been defined, the name must
first be reserved using the `setGeneric` function. The `setMethod` can then be used
to define which function is called based on the class names of the objects sent
to it.

We define the methods associated with the Agent method given in the previous
section. Note that the `validity` function for an object is only called when it is
first created and when an explicit call to the `validObject` function is made. We
make use of the `validObject` command in the methods below that are used to change
the value of a data element within an object.

```{r}
# create a method to assign the value of the location
setGeneric(name="setLocation", def = function(theObject,position) {
                               standardGeneric("setLocation")
                       })

setMethod(f="setLocation", signature="Agent", 
          definition=function(theObject, position) {
                              theObject@location <- position
                              validObject(theObject)
                              return(theObject)
                      })

# create a method to get the value of the location
setGeneric(name="getLocation", def=function(theObject) {
                               standardGeneric("getLocation")
                       })

setMethod(f="getLocation", signature="Agent", definition=function(theObject) {
                              return(theObject@location)
                      })


# create a method to assign the value of active
setGeneric(name="setActive", def=function(theObject,active) {
                               standardGeneric("setActive")
                       })

setMethod(f="setActive", signature="Agent", 
          definition=function(theObject, active) {
                              theObject@active <- active
                              validObject(theObject)
                              return(theObject)
                      })

# create a method to get the value of active
setGeneric(name="getActive", def=function(theObject) {
                               standardGeneric("getActive")
                       })

setMethod(f="getActive", signature="Agent", definition=function(theObject) {
                              return(theObject@active)
                      })


# create a method to assign the value of velocity
setGeneric(name="setVelocity", def=function(theObject,velocity) {
                               standardGeneric("setVelocity")
                       })

setMethod(f="setVelocity", signature="Agent", definition=function(theObject,velocity) {
                              theObject@velocity <- velocity
                              validObject(theObject)
                              return(theObject)
                      })

# create a method to get the value of the velocity
setGeneric(name="getVelocity", def=function(theObject) {
                               standardGeneric("getVelocity")
                       })

setMethod(f="getVelocity", signature="Agent", definition=function(theObject) {
                              return(theObject@velocity)
                      })
```

With these definitions the data elements are encapsulated and can be accessed
and set using the methods given above. It is generally good practice in object
oriented programming to keep your data private and not show them to everybody
willy nilly.

```{r}
a <- Agent()
getVelocity(a)

a <-  setVelocity(a, c(1, 2))
getVelocity(a)
```


## Overloading
The last topic examined is the idea of overloading functions. In the examples
above the signature is set to a single element. The signature is a vector of
characters and specifies the data types of the argument list for the method to
be defined. Here we create two new methods. The name of the method is
`resetActivity`, and there are two versions.

The first version accepts two arguments whose types are `Agent` and logical. This
version of the method will set the activity slot to a given value. The second
version accepts two arguments whose types are Agent and numeric. This version
will set the activity to TRUE and then set the energy level to the value passed
to it. Note that the names of the variables in the argument list must be exactly
the same.

```{r}
# create a method to reset the velocity and the activity
setGeneric(name = "resetActivity", def = function(theObject,value) {
                               standardGeneric("resetActivity")
                       })

setMethod(f = "resetActivity", 
          signature = c("Agent", "logical"), 
          definition = function(theObject, value) { 
              theObject <- setActive(theObject, value) 
              theObject <- setVelocity(theObject, c(0.0,0.0)) 
              return(theObject)
              })

setMethod(f="resetActivity", 
          signature = c("Agent", "numeric"), 
          definition = function(theObject, value) { 
              theObject <- setActive(theObject, TRUE)
              theObject <- setVelocity(theObject, value) 
              return(theObject)
              })
```

This definition of the function yields two options for the resetActivity
function. The decision to determine which function to call depends on two
arguments and their type. For example, if the first argument is from the Agent
class and the second is a value of TRUE or FALSE, then the first version of the
function is called. Otherwise, if the second argument is a number the second
version of the function is called.

```{r}
a <- Agent()
a

a <- resetActivity(a, FALSE)
getActive(a)

a <- resetActivity(a, c(1,3))
getVelocity(a)
```

