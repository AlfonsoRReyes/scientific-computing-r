---
title: "R Notebook"
output: html_notebook
---

http://adv-r.had.co.nz/Computing-on-the-language.html


`substitute()` makes non-standard evaluation possible. It looks at a function argument and instead of seeing the value, it sees the code used to compute the value:

```{r}
f <- function(x) {
  substitute(x)
}
f(1:10)
```

```{r}
x <- 10
f(x)
```

```{r}
y <- 13
f(x + y^2)
```

> substitute() works because function arguments are represented by a special type of object called a promise. A promise captures the expression needed to compute the value and the environment in which to compute it. You’re not normally aware of promises because the first time you access a promise its code is evaluated in its environment, yielding a value.


substitute() is often paired with deparse(). That function takes the result of substitute(), an expression, and turns it into a character vector.


```{r}
g <- function(x) deparse(substitute(x))
g(1:10)
```

```{r}
g(x + y^2)
```

## Exercise

4. f(), defined above, just calls substitute(). Why can’t we use it to define g()? In other words, what will the following code return? First make a prediction. Then run the code and think about the results.

```{r}
f <- function(x) substitute(x)
g <- function(x) deparse(f(x))
g(1:10)
g(x)
g(x + y ^ 2 / z + exp(a * sin(b)))
```

```{r}
f(1:10)
f(x)
f(x + y ^ 2 / z + exp(a * sin(b)))
```

## subset

subset() is special because it implements different scoping rules: the expressions a >= 4 or b == c are evaluated in the specified data frame rather than in the current or global environments. This is the essence of non-standard evaluation.

How does subset() work? We’ve already seen how to capture an argument’s expression rather than its result, so we just need to figure out how to evaluate that expression in the right context. Specifically, we want x to be interpreted as sample_df$x, not globalenv()$x. To do this, we need eval(). This function takes an expression and evaluates it in the specified environment.

### eval(), quote()
Before we can explore eval(), we need one more useful function: quote(). It captures an unevaluated expression like substitute(), but doesn’t do any of the advanced transformations that can make substitute() confusing. quote() always returns its input as is:

```{r}
substitute(1:10)
substitute(x)
substitute(x + y ^ 2 / z + exp(a * sin(b)))
```

```{r}
quote(1:10)
quote(x)
quote(x + y ^ 2 / z + exp(a * sin(b)))
```

We need quote() to experiment with eval() because eval()’s first argument is an expression. So if you only provide one argument, it will evaluate the expression in the current environment. This makes eval(quote(x)) exactly equivalent to x, regardless of what x is:

```{r}
eval(quote(x <- 1))
eval(quote(x))
```


```{r}
quote(2 + 2)
```

```{r}
eval(quote(2 + 2))
```

```{r}
eval(eval(quote(quote(2 + 2))))
```

eval()’s second argument specifies the environment in which the code is executed:

```{r}
e <- new.env()
e$x <- 20
eval(quote(x), e)
```

Because lists and data frames bind names to values in a similar way to environments, eval()’s second argument need not be limited to an environment: it can also be a list or a data frame.

```{r}
eval(quote(x), list(x = 30))
```

```{r}
eval(quote(x), data.frame(x = 40))
```


### quote(), subset()

```{r}
sample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))

eval(quote(a >= 4), envir= sample_df)
```


```{r}
eval(quote(b == c), envir = sample_df)
```

A common mistake when using eval() is to forget to quote the first argument. Compare the results below:


```{r}
a <- 10
eval(quote(a), sample_df)
```

```{r}
eval(a, sample_df)
```


## eval(), substitute(), subset()
We can use eval() and substitute() to write subset(). We first capture the call representing the condition, then we evaluate it in the context of the data frame and, finally, we use the result for subsetting:

```{r}
subset2 <- function(x, condition) {
  condition_call <- substitute(condition)
  r <- eval(condition_call, envir = x)
  x[r, ]
}

subset2(sample_df, a >= 4)
```


```{r}
sample_df[sample_df$a >= 4, ]
```

## Exercises

2. subset2() has a bug if you use it with a single column data frame. What should the following code return? How can you modify subset2() so it returns the correct type of object?

```{r}
# sample_df2 <- data.frame(x = 1:10, y = 5:14)
sample_df2 <- data.frame(x = 1:10)
subset2(sample_df2, x > 8)
```

```{r}
subset2.1 <- function(x, condition) {
  condition_call <- substitute(condition)
  r <- eval(condition_call, envir = x)
  as.data.frame(x[r, ])
}

sample_df2 <- data.frame(x = 1:10)
subset2.1(sample_df2, x > 8)
```

5. The third argument in subset() allows you to select variables. It treats variable names as if they were positions. This allows you to do things like subset(mtcars, , -cyl) to drop the cylinder variable, or subset(mtcars, , disp:drat) to select all the variables between disp and drat. How does this work? I’ve made this easier to understand by extracting it out into its own function.

```{r}
select <- function(df, vars) {
  vars <- substitute(vars)
  var_pos <- setNames(as.list(seq_along(df)), names(df))
  pos <- eval(vars, var_pos)
  df[, pos, drop = FALSE]
}

select(mtcars, -cyl)
```

```{r}
names(mtcars)
seq_along(mtcars)

# as.list(seq_along(mtcars))
setNames(as.list(seq_along(mtcars)), names(mtcars))
```

eval() takes an expression and evaluates it in the specified environment.

```{r}
# the way eval works is similar to asking for the value of a variable
# in the global environment, with the difference that the environment is
# set on the 2nd argument
eval(substitute(cyl), envir = setNames(as.list(seq_along(mtcars)), names(mtcars)))
eval(substitute(drat), setNames(as.list(seq_along(mtcars)), names(mtcars)))
eval(substitute(qsec), setNames(as.list(seq_along(mtcars)), names(mtcars)))
```

```{r}
mtcars[, eval(substitute(-cyl), 
            setNames(as.list(seq_along(mtcars)), names(mtcars))), drop = FALSE]
```


```{r}
select(mtcars, -c(cyl, qsec, drat))
```

# Scoping issues
It certainly looks like our subset2() function works. But since we’re working with expressions instead of values, we need to test things more extensively. For example, the following applications of subset2() should all return the same value because the only difference between them is the name of a variable:


```{r}
y <- 4
x <- 4
condition <- 4
condition_call <- 4

subset2(sample_df, a == 4)
```


```{r}
subset2(sample_df, a == y)

```



```{r}
subset2(sample_df, a == x)
 
#   a   b   c
# 1	1	5	5	
# 2	2	4	3	
# 3	3	3	1	
# 4	4	2	4	
# 5	5	1	1	
# NA	NA	NA	NA	
# NA.1	NA	NA	NA
# 7 rows
```



```{r}
subset2(sample_df, a == condition)
# 0 rows
```

> What went wrong? You can get a hint from the variable names I’ve chosen: they are all names of variables defined inside subset2(). If eval() can’t find the variable inside the data frame (its second argument), it looks in the environment of subset2(). That’s obviously not what we want, so we need some way to tell eval() where to look if it can’t find the variables in the data frame.

The key is the third argument to `eval(): enclos`. This allows us to specify a parent (or enclosing) environment for objects that don’t have one (like lists and data frames). If the binding is not found in env, eval() will next look in `enclos`, and then in the parents of enclos. enclos is ignored if env is a real environment. We want to look for x in the environment from which subset2() was called. In R terminology this is called the **parent frame** and is accessed with parent.frame(). This is an example of dynamic scope: the values come from the location where the function was called, not where it was defined.

With this modification our function now works:

```{r}
subset2 <- function(x, condition) {
  condition_call <- substitute(condition)
  r <- eval(condition_call, x, parent.frame())
  x[r, ]
}

x <- 4
subset2(sample_df, a == x)
```

```{r}
subset2(sample_df, a == condition)
```

> Using enclos is just a shortcut for converting a list or data frame to an environment. We can get the same behaviour by using list2env(). It turns a list into an environment with an explicit parent:

```{r}
subset2a <- function(x, condition) {
  condition_call <- substitute(condition)
  env <- list2env(x, parent = parent.frame())
  r <- eval(condition_call, env)
  x[r, ]
}

x <- 5
subset2a(sample_df, a == x)
```


## Exercises
1. plyr::arrange() works similarly to subset(), but instead of selecting rows, it reorders them. How does it work? What does substitute(order(...)) do? Create a function that does only that and experiment with it.

```{r}
plyr.arrange <- function (df, ...)  {
    stopifnot(is.data.frame(df))
    ord <- eval(substitute(order(...)), df, parent.frame())
    if (length(ord) != nrow(df)) {
        stop("Length of ordering vectors don't match data frame size", 
            call. = FALSE)
    }
    unrowname(df[ord, , drop = FALSE])
}
```




2. What does transform() do? Read the documentation. How does it work? Read the source code for transform.data.frame(). What does substitute(list(...)) do?

```{r}
transform_data.frame <- function (`_data`, ...) {
    e <- eval(substitute(list(...)), `_data`, parent.frame())
    tags <- names(e)
    inx <- match(tags, names(`_data`))
    matched <- !is.na(inx)
    if (any(matched)) {
        `_data`[inx[matched]] <- e[matched]
        `_data` <- data.frame(`_data`)
    }
    if (!all(matched)) 
        do.call("data.frame", c(list(`_data`), e[!matched]))
    else `_data`
}
```


3. plyr::mutate() is similar to transform() but it applies the transformations sequentially so that transformation can refer to columns that were just created:

```{r}
plyr.mutate <- function (.data, ...)  {
    stopifnot(is.data.frame(.data) || is.list(.data) || is.environment(.data))
    cols <- as.list(substitute(list(...))[-1])
    cols <- cols[names(cols) != ""]
    for (col in names(cols)) {
        .data[[col]] <- eval(cols[[col]], .data, parent.frame())
    }
    .data
}
```


4. What does with() do? How does it work? Read the source code for with.default(). What does within() do? How does it work? Read the source code for within.data.frame(). Why is the code so much more complex than with()?

```{r}
with_default <- function (data, expr, ...) 
eval(substitute(expr), data, enclos = parent.frame())

```


