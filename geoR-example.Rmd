---
title: "R Notebook"
output: html_notebook
---

http://www.leg.ufpr.br/geoR/geoRdoc/vignette/geoRintro/geoRintrose7.html



```{r}
library(geoR)

data(s100)
summary(s100)
```

## 3.1 Plotting data locations and values

The function plot.geodata shows a 2 × 2 display with data locations (top plots) and data versus coordinates (bottom plots). For an object of the class geodata the command plot(s100) produce the output shown in Figure 3.1.

```{r}
plot.geodata(s100)
```

The function points.geodata produces a plot showing the data locations. Alternatively, points indicating the data locations can be added to a current plot. There are options to specify point sizes, patterns and colors, which can be set to be proportional to the data values or speciﬁed quantiles. Some examples of graphical outputs are illustrated by the commands below and corresponding plots as shown in Figure 2.

```{r}
par(mfrow = c(2, 2)) 
points(s100, xlab = "Coord X", ylab = "Coord Y") 
points(s100, xlab = "Coord X", ylab = "Coord Y", pt.divide = "rank.prop") 
points(s100, xlab = "Coord X", ylab = "Coord Y", 
       cex.max = 1.7, col = gray(seq(1, 0.1, l = 100)), 
       pt.divide = "equal") 
points(s100, pt.divide = "quintile", xlab = "Coord X", 
       ylab = "Coord Y")
```

## Emprirical variograms
Empirical variograms are calculated using the function variog. There are options for the classical or modulus estimator. Results can be returned as variogram clouds, binned or smoothed variograms. There are methods for plot to facilitate the display of the results as shown in Figure 3.


```{r fig.asp=1}
cloud1 <- variog(s100, option = "cloud", max.dist = 1) 
cloud2 <- variog(s100, option = "cloud", estimator.type = "modulus", 
       max.dist = 1) 
bin1 <- variog(s100, uvec = seq(0, 1, l = 11)) 
bin2 <- variog(s100, uvec = seq(0, 1, l = 11), 
    estimator.type = "modulus") 
par(mfrow = c(2, 2)) 
plot(cloud1, main = "classical estimator") 
plot(cloud2, main = "modulus estimator") 
plot(bin1, main = "classical estimator") 
plot(bin2, main = "modulus estimator")
```

Several results are returned by the function variog. The ﬁrst three are the more important ones and contains the distances, the estimated semivariance and the number of pairs for each bin.


```{r}
names(bin1)
```

Furthermore, the points of the variogram clouds can be grouped into classes of distances ("bins") and displayed with a box-plot for each bin as shown in Figure 3.2. This can be used as an exploratory tool to access variogram results.

```{r}

bin1 <- variog(s100, uvec = seq(0, 1, l = 11), 
    bin.cloud = T) 
bin2 <- variog(s100, uvec = seq(0, 1, l = 11), 
    estimator.type = "modulus", bin.cloud = T) 
par(mfrow = c(1, 2)) 
plot(bin1, bin.cloud = T, main = "classical estimator") 
plot(bin2, bin.cloud = T, main = "modulus estimator")

```

# 4 Parameter Estimation

An example call to likfit is given below. Methods for print() and summary() have been written to summarize the resulting objects.

```{r}
ml <- likfit(s100, ini = c(1, 0.5))
```

```{r}
summary(ml)
```

The commands below shows how to ﬁt models by using different methods, with options for ﬁxed or estimated nugget parameter. Notice there are other features not illustrated here such as estimation of trends, anisotropy, smoothness and Box-Cox transformation parameter. Notice in the call above that the functions show some messages while they are running — and we don’t want to see them in the following calls. To prevent this we can set the argument messages = FALSE at each function call or, to set it globally for all functions use options() as follows.

## Fitting models with nugget ﬁxed to zero

```{r}
ml <- likfit(s100, ini = c(1, 0.5), fix.nugget = T) 
reml <- likfit(s100, ini = c(1, 0.5), fix.nugget = T, 
    method = "RML") 
ols <- variofit(bin1, ini = c(1, 0.5), fix.nugget = T, 
    weights = "equal") 
wls <- variofit(bin1, ini = c(1, 0.5), fix.nugget = T)
```

## Fitting models with a ﬁxed value for the nugget

```{r}
ml.fn <- likfit(s100, ini = c(1, 0.5), fix.nugget = T, 
    nugget = 0.15) 
reml.fn <- likfit(s100, ini = c(1, 0.5), fix.nugget = T, 
    nugget = 0.15, method = "RML") 
ols.fn <- variofit(bin1, ini = c(1, 0.5), fix.nugget = T, 
    nugget = 0.15, weights = "equal") 
wls.fn <- variofit(bin1, ini = c(1, 0.5), fix.nugget = T, 
    nugget = 0.15)
```

## Fitting models estimated nugget

```{r}
ml.n <- likfit(s100, ini = c(1, 0.5), nug = 0.5) 
reml.n <- likfit(s100, ini = c(1, 0.5), nug = 0.5, 
    method = "RML") 
ols.n <- variofit(bin1, ini = c(1, 0.5), nugget = 0.5, 
    weights = "equal") 
wls.n <- variofit(bin1, ini = c(1, 0.5), nugget = 0.5)
```

Now, the comands for plotting ﬁtted models against empirical variogram as show in Figure 4 are:

```{r}
par(mfrow = c(1, 3)) 
plot(bin1, main = expression(paste("fixed ", tau^2 == 
    0))) 
lines(ml, max.dist = 1) 
lines(reml, lwd = 2, max.dist = 1) 
lines(ols, lty = 2, max.dist = 1) 
lines(wls, lty = 2, lwd = 2, max.dist = 1) 
legend(0.5, 0.3, legend = c("ML", "REML", "OLS", 
    "WLS"), lty = c(1, 1, 2, 2), lwd = c(1, 2, 
    1, 2), cex = 0.7) 
plot(bin1, main = expression(paste("fixed ", tau^2 == 
    0.15))) 
lines(ml.fn, max.dist = 1) 
lines(reml.fn, lwd = 2, max.dist = 1) 
lines(ols.fn, lty = 2, max.dist = 1) 
lines(wls.fn, lty = 2, lwd = 2, max.dist = 1) 
legend(0.5, 0.3, legend = c("ML", "REML", "OLS", 
    "WLS"), lty = c(1, 1, 2, 2), lwd = c(1, 2, 
    1, 2), cex = 0.7) 
plot(bin1, main = expression(paste("estimated  ", 
    tau^2))) 
lines(ml.n, max.dist = 1) 
lines(reml.n, lwd = 2, max.dist = 1) 
lines(ols.n, lty = 2, max.dist = 1) 
lines(wls.n, lty = 2, lwd = 2, max.dist = 1) 
legend(0.5, 0.3, legend = c("ML", "REML", "OLS", 
    "WLS"), lty = c(1, 1, 2, 2), lwd = c(1, 2, 
    1, 2), cex = 0.7)
```

Two kinds of variogram envelopes computed by simulation are illustrated in the ﬁgure below.

The plot on the left-hand side shows an envelope based on permutations of the data values across the locations, i.e. envelopes built under the assumption of no spatial correlation. The envelopes shown on the right-hand side are based on simulations from a given set of model parameters, in this example the parameter estimates from the WLS variogram ﬁt. This envelope shows the variability of the empirical variogram.

```{r}
env.mc <- variog.mc.env(s100, obj.var = bin1) 
env.model <- variog.model.env(s100, obj.var = bin1, 
       model = wls)
```

```{r}
par(mfrow = c(1, 2)) 
plot(bin1, envelope = env.mc) 
plot(bin1, envelope = env.model)
```

```{r}
prof <- proflik(ml, geodata = s100, sill.val = seq(0.48, 
       2, l = 11), range.val = seq(0.1, 0.52, l = 11), 
       uni.only = FALSE) 
par(mfrow = c(1, 3)) 
plot(prof, nlevels = 16)
```

# 5 Cross-Validation

The function xvalid performs cross-validation either using the leaving-one-out strategy or using a different set of locations provided by the user through the argument ‘location.xvalid’.

For the ﬁrst strategy, data points are removed one by one and predicted by kriging using the remaining data. The commands below illustrates cross-validation for the models ﬁtted by maximum likelihood and weighted least squares. In the following two calls the model parameters remains the same for the prediction at each location.



```{r}
xv.ml <- xvalid(s100, model = ml) 
xv.wls <- xvalid(s100, model = wls)
```

Graphical results are shown for the cross-validation results where the leaving-one-out strategy combined with the wls estimates for the parameters was used. Cross-validation residuals are obtained subtracting the observed data minus the predicted value. Standardised residuals are obtained dividing by the square root of the prediction variance (‘kriging variance’). By default the 10 plots shown in the Figure 10 are produced but the user can restrict the choice using the function arguments.


```{r}
par(mfcol = c(5, 2), mar = c(3, 3, 1, 0.5), mgp = c(1.5, 
       0.7, 0)) 
plot(xv.wls)
```

A variation of this method is illustrated by the next two calls where the model parameters are re-estimated each time a point is removed from the data-set. 
WARNING: RUNNING THE NEXT COMMAND CAN BE TIME-CONSUMING


```{r}
xvR.ml <- xvalid(s100, model = ml, reest = TRUE) 
xvR.wls <- xvalid(s100, model = wls, reest = TRUE, 
       variog.obj = bin1)
```



# 6 Spatial Interpolation

Conventional geostatistical spatial interpolation (kriging) can be performed with options for:

Simple kriging
Ordinary kriging
Trend (universal) kriging
External trend kriging
There are additional options for Box-Cox transformation (and back transformation of the results) and anisotropic models. Simulations can be drawn from the resulting predictive distributions if requested.

As a ﬁrst example consider the prediction at four locations labeled 1, 2, 3, 4 and indicated in the ﬁgure below.

```{r}
plot(s100$coords, xlim = c(0, 1.2), ylim = c(0, 
     1.2), xlab = "Coord X", ylab = "Coord Y") 
loci <- matrix(c(0.2, 0.6, 0.2, 1.1, 0.2, 0.3, 
    1, 1.1), ncol = 2) 
text(loci, as.character(1:4), col = "red") 
polygon(x = c(0, 1, 1, 0), y = c(0, 0, 1, 1), 
    lty = 2)
```

The command to perform ordinary kriging using the parameters estimated by weighted least squares with nugget ﬁxed to zero would be:

```{r}
kc4 <- krige.conv(s100, locations = loci, krige = krige.control(obj.m = wls))
```

The output is a list including the predicted values (kc4$predict) and the kriging variances (kc4$krige.var).

Consider now a second example. The goal is to perform prediction on a grid covering the area and to display the results. Again, we use ordinary kriging. The commands commands below deﬁnes a grid of locations and performs the prediction at those locations.


```{r}
pred.grid <- expand.grid(seq(0, 1, l = 51), seq(0, 
       1, l = 51)) 
kc <- krige.conv(s100, loc = pred.grid, krige = krige.control(obj.m = ml))
```



## 
Consider now a second example. The goal is to perform prediction on a grid covering the area and to display the results. Again, we use ordinary kriging. The commands commands below deﬁnes a grid of locations and performs the prediction at those locations.

A method for the function image can be used for displaying predicted values as shown in the next Figure, as well as other prediction results returned by krige.conv.

```{r}
image(kc, loc = pred.grid, col = gray(seq(1, 0.1, 
       l = 30)), xlab = "Coord X", ylab = "Coord Y")
```


##
Consider now, under the same model assumptions, obtaining simulations from the predictive distributions on a grid of points covering the area. The commands to deﬁne the grid and perform Bayesian prediction are:

```{r}
pred.grid <- expand.grid(seq(0, 1, l = 31), seq(0, 
       1, l = 31)) 
bsp <- krige.bayes(s100, loc = pred.grid, prior = prior.control(phi.discrete = seq(0, 
       5, l = 51)), output = output.control(n.predictive = 2))
```

Maps with the summaries and simulations of the predictive distribution can be plotted as follows.


```{r}
par(mfrow = c(2, 2), mar = c(3, 3, 1, 0.5), mgp = c(1.5, 
       0.7, 0)) 
image(bsp, loc = pred.grid, main = "predicted", 
       col = gray(seq(1, 0.1, l = 30))) 
image(bsp, val = "variance", loc = pred.grid, 
       main = "prediction variance", col = gray(seq(1, 
           0.1, l = 30))) 
image(bsp, val = "simulation", number.col = 1, 
       loc = pred.grid, main = "a simulation from\nthe predictive distribution", 
       col = gray(seq(1, 0.1, l = 30))) 
image(bsp, val = "simulation", number.col = 2, 
       loc = pred.grid, main = "another simulation from \n the predictive distribution", 
       col = gray(seq(1, 0.1, l = 30)))
```



