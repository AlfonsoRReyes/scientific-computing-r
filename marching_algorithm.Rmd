---
title: "R Notebook"
output: html_notebook
---



```{r}
# 1 read all the input data for the current pipe segment:
#   oil.rt, gas.rt, oil.sg, gas.sg, L, diam, angle, temp.grad
#   and initial pressure


# 2 set the calculation increment dL = L / n. Usually n = 30

  

# 3 guess initial outlet pressure. Can assume 0.002 psi/ft. p.guess
  

# 4 calculate the average pressure: p.avg = (p + p.guess) /2
  p.avg = (p + dp.dz * dL)

# 5 calculate the fluid properties at P and T
#   oil.fvf, gas.fvf, oil.rt, gas.rt, oil.supvel, gas.supvel


# 6 calculate the pressure gradient dp.dz (-dP/dL)


# 7 calculate the outlet-calculated pressure: p.calc = p - (-dp.dz)

# 8 compare the guessed and calculated outlet pressures:
#   (p.guess - p.calc) / p.calc should be less than the tolerance
#   otherwise, increase iteration and make p.guess = p.calc


# 9 Repeat 1 to 6 until convergence achieved. Ten iterations is the usual.


# 10 when convergence is achive, move to the next pipe increment
#    p2.inlet = p1.outlet

# 11 Repeat for all pipe increments and calculate p and dp.dz
#    for the current segment

# 12 If there are more pipe segments, repeat calculation 1-11 

```


```{r rows.print=30}
tol       = 0.001
thp       = 200          # initial pressure

p         = thp
depth.wh  = 0
depth.bh  = 9700
pipe.incr = 30


depths <- seq.int(from = depth.wh, to = depth.bh, length.out = pipe.incr)
n      <- length(depths)   # which is the same as pipe.incr

dL = 300
dp.dz = 0.002
p0    = thp

for (i in seq_len(n)) {
  dL = depths[i+1] - depths[i]
  p1 = p0 + dp.dz * dL
  eps = 1
  iter = 1
  while (eps > tol) {             # loop until AE greater than tolerance
    p.avg = (p0 + p1) / 2
    dp.dz = log10(p.avg)           # calculate gradient as function of `pavg`
    p.calc = p0 - (-dp.dz) * dL
    eps <- abs( (p1 - p.calc) / p.calc )
    if (eps >= tol) p1 = p.calc
    iter = iter + 1
    
    #cat(iter, p0, p1, p.avg, dp.dz, eps, "\n")
  }  
  cat(i, p0, p1, iter, dp.dz, "\n")
  p0 = p1
  
}

```


## Marching algorithm with smaller tolerance
It uses a dummy function $grad = f(p_{avg})$. Also includes iteration counter `iter`

```{r}
# iterating using marching algorithm
tol = 0.00001   # tolerance
pin = 200       # initial pressure
grad = 0.002
dL = 300        # segment length
p0 = pin        # initial pressure
eps = 1         # initial absolute error

cat(sprintf("%2s %6s %8s %8s %8s %9s %9s \n",                 # header
            "it", "p0", "p1", "pavg", "pcalc", "grad", "eps"))

p1 = p0 + grad * dL         # first pressure guess
iter = 1

while (eps > tol) {         # loop until AE greater than tolerance
  pavg  = (p0 + p1) / 2     # take the average
  grad  = log10(pavg)       # calculate gradient as function of `pavg`
  pcalc = p0 + grad * dL    # calculate new pressure
  eps = abs((p1 - pcalc) / pcalc)   # compare guess and calculation
  
  cat(sprintf("%2d %6.1f %8.2f %8.2f %8.2f %9.6f %9.6f \n", 
            iter, p0, p1, pavg, pcalc, grad, eps))
  
  if (eps >= tol) p1 = pcalc        # if AE too big take a new guess
  iter = iter + 1
} 
```

If we move the print() after the `iter` then we get values after a new $p_{i+1}$ calculation, which is not correct.

```
   p0     p1   pavg    pcalc      eps   grad 
 200.0  890.5  200.3    890.5  0.77473 2.3017 
 200.0 1021.0  545.3   1021.0  0.12779 2.7366 
 200.0 1035.7  610.5   1035.7  0.01422 2.7857 
 200.0 1037.3  617.9   1037.3  0.00151 2.7909 
 200.0 1037.4  618.6   1037.4  0.00016 2.7914 
 200.0 1037.4  618.7   1037.4  0.00002 2.7915 
 200.0 1037.4  618.7   1037.4  0.00000 2.7915 

```


## Another marching algorithm with different initial value
It uses gradient and initial pressure
```{r}
tol = 0.01
pin = 200
grad = 0.002
dL = 300

p0 = pin
eps = 1

cat(sprintf("%6s %6s %6s %8s %8s %6s \n", "p0", "p1", "pavg", "pcalc", "eps", "grad"))

p1 = p0 + grad * dL      # first pressure guess
while (eps > tol) {       # loop until epsilon greater than tolerance
  
  pavg = (p0 + p1)/2       # take the average
  grad = log10(pavg)      # calculate gradient with pavg
  pcalc = p0 + grad * dL  # calculate new pressure
  eps = abs((p1 - pcalc) / pcalc)   # compare guess and calculation

  cat(sprintf("%6.1f %6.1f %6.1f %8.1f %8.5f %6.4f \n", 
            p0, p1, pavg, pcalc, eps, grad))
    
  if (eps >= tol) {        # if 
    p1 = pcalc
  }
} 
```


## simple marching algorithm
Uses any function and any variable
```{r}
# very simple marching algorithm 
tol = 0.0001
ini = 4
guess = 0.25
eps = 1
var0 = ini

cat(sprintf("%2s %8s %8s %8s %8s %8s \n", "i", "var0", "var1", "avg", "calc", "eps" ))
var1 = var0 + guess
i = 1
while (eps > tol) {
  avg = (var0 + var1) / 2
  calc = log(avg + avg^2/2 + avg^3)^0.5      # any function here `f(avg)`
  eps = abs((var1 - calc) / calc)            # absolute error
  
  cat(sprintf("%2d %f %f %f %f %f\n", i, var0, var1, avg, calc, eps))
  
  if (eps >= tol) var1 = calc
  i = i + 1
}
```



```{r}

# while infinite loop with break

i = 0
while (TRUE) {
  cat(i, "\n")
  i = i + 1
  if (i >= 10) break   # exit when hitting 10 numbers
}
```





### 7 calculate the outlet-calculated pressure

$$p_{i+1(C)} = p_i - (\frac {dP}{dL})_i dL_i $$

### 8 compare the guessed and calculated outlet pressures

$$| ( p_{i+1(G)} - p_{i+1(C)} ) / p_{i+1(C)} | < \epsilon$$