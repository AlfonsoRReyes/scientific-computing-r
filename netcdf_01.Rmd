---
title: "netcdf versus HDF5"
output: html_notebook
---
## `netcdf` Datasets
Datasets can be found here: http://geog.uoregon.edu/GeogR/topics/raster02.html

------

## NetCDF in R
Source: http://geog.uoregon.edu/bartlein/courses/geog607/Rmd/netCDF_01.htm

NetCDF is a self-documenting, machine-independent format for creating and distributing arrays of gridded data. Originally developed for storing and distributing climate data, such as those generated by climate simulation or reanalysis models, the format and protocols can be used for other gridded data sets. netCDF libraries are maintained by Unidata http://www.unidata.ucar.edu/software/netcdf/ and there are a number of applications for producing simple visualizations of NetCDF files, such as Panoply, http://www.giss.nasa.gov/tools/panoply/.

The R packages ncdf, ncdf4 and raster provide the support necessary for reading and writing NetCDF files. The package ncdf is available on both Windows and Mac OS X, but supports only the older NetCDF 3 formats, while ncdf4 is available only for the Mac OS X (as of May 2013).

The following examples make use of a NetCDF file of climate data from the Climate Research Unit http://www.cru.uea.ac.uk/data, consisting of long-term mean values (1961-1990) of near-surface air temperature on a 0.5-degree grid (for land points). The dimensions of the array are 720 (longitudes) x 360 (latitudes) x 12 (months).

```{r}
library(ncdf4)
library(chron)
library(RColorBrewer)
library(lattice)

ncname <- "cru10min30_tmp"  
ncfname <- paste(ncname,".nc", sep="")
dname <- "tmp"                          # note: tmp means temperature (not temporary)

# open a netCDF file
ncin <- nc_open(ncfname)
print(ncin)
```

Next, the coordinate variables longitude and latitude are read using the ncdf get.var.ncdf() function, and the first few values of each are listed using the head() and tail() functions. The number of longitude and latitude values are determined using the `dim` function:

```{r}
lon <- ncvar_get(ncin, "lon")
nlon <- dim(lon)
head(lon)
```

```{r}
lat <- ncvar_get(ncin, "lat", verbose = F)
nlat <- dim(lat)
head(lat)
```

```{r}
print(c(nlon, nlat))     # confirms the dimensions of the data
```

Next, read the time variable (again using the get.var.ncdf() function), and its attribute units (using the att.get.ncdf() function). Time here is expressed in the udunits “time since…” format, and will be converted to a human-readable form later.
```{r}
t <- ncvar_get(ncin, "time")
tunits <- ncatt_get(ncin, "time", "units")

t  # list the values
```

```{r}
tname  <- "time"
tunits <- ncatt_get(ncin, tname, "units")
tcal   <- ncatt_get(ncin, tname, "calendar")
taxis <- ncatt_get(ncin, tname, "axis")
# etc.

tunits$value
tcal$value
taxis$value
```



```{r}
nt <- dim(t)      # get the number of values and list them
nt
```

Print the time units string. Note the structure of the time units attribute. The object `tunits` has two components `hasatt` (a logical variable), and `tunits$value`, the actual “time since” string.
```{r}
tunits
```

The variable and its longname, units and fill value (_FillValue) attributes are read next.
```{r}
tmp.array <- ncvar_get(ncin, dname)                 # dname is the variable
dlname    <- ncatt_get(ncin, dname, "long_name")
dunits    <- ncatt_get(ncin, dname, "units")
fillvalue <- ncatt_get(ncin, dname, "_FillValue")
source    <- ncatt_get(ncin, dname, "source")
```


```{r}
dlname$value
dunits$value
fillvalue$value
source$value
```

Same as Panoply:

      Variable "tmp"
       
      float tmp(time=12, lat=360, lon=720);
        :long_name = "air_temperature";
        :units = "degC";
        :_FillValue = -99.0f; // float
        :source = "E:\\Projects\\cru\\data\\cru_cl_2.0\\nc_files\\cru10min_tmp.nc";


The dimensions of the array containing the values of the variables can be confirmed using the dim() function:

```{r}
dim(tmp.array)
# three dimensions
```

Next, a set of “global attributes” (or metadata) are read.
```{r}
data        <- ncatt_get(ncin, 0, "data")
title       <- ncatt_get(ncin, 0, "title")
institution <- ncatt_get(ncin, 0, "institution")
datasource  <- ncatt_get(ncin, 0, "source")
references  <- ncatt_get(ncin, 0, "references")
history     <- ncatt_get(ncin, 0, "history")
Conventions <- ncatt_get(ncin, 0, "Conventions")
```

The attribute values can be listed by printing thier values, e.g.

```{r}
data$value
title$value
institution$value
datasource$value
references$value
history$value
Conventions$value
```

Same output as in Panoply:

       // global attributes:
        :data = "CRU CL 2.0 1961-1990 Monthly Averages";
        :title = "CRU CL 2.0 -- 10min grid sampled every 0.5 degree";
        :institution = "http://www.cru.uea.ac.uk/";
        :source = "http://www.cru.uea.ac.uk/~markn/cru05/cru05_intro.html";
        :references = "New et al. (2002) Climate Res 21:1-25";
        :history = "Wed Oct 29 11:27:35 2014: ncrename -v climatology_bounds,time_bounds cru10min30_tmp.nc\nP.J. Bartlein, 19 Jun 2005";
        :Conventions = "CF-1.0";


At this point, we're done with the input data set, so close it.

```{r}
nc_close(ncin)
```


### convert the time variable
The time variable, in “time-since” units can be converted into “real” (or more easily readable) time values by splitting the time tunits$value string into its component parts, and then using the chron() function to determine the absolute value of each time value from the time origin.

```{r}
# split the time units string into fields
tustr <- strsplit(tunits$value, " ")
tdstr <- strsplit(unlist(tustr)[3], "-")
tmonth = as.integer(unlist(tdstr)[2])
tday = as.integer(unlist(tdstr)[3])
tyear = as.integer(unlist(tdstr)[1])
chron(t, origin = c(tmonth, tday, tyear))
```

### Replace NetCDF fillvalues with R NAs

In NetCDF file, values of a variable that are either missing or simply not available (i.e. ocean grid points in a terrestrial data set) are flagged using specific “fill values” (_FillValue) or missing values (missing_value), the values of which are set as attributes of a variable. In R, such unavailable data are indicated using the “NA” value. The following code fragment illustrates how to replace the NetCDF variable's fill values with R NA's .

```{r}
tmp.array[tmp.array == fillvalue$value] <- NA
```

The head() function can be used before and after executing the “square bracket” seclection and replacement to verify that the NA values have indeed replace the NetCDF fill values. The total number of non-missing (i.e. land, except for Antarctica) grid cells can be gotten by determining the length of a vector of values representing one slice from the brick, omitting the NA values:

```{r}
length(na.omit(as.vector(tmp.array[, , 1])))
```


### Get a single time slice of the data, create an R data frame, and write a .csv file

NetCDF variables are read and written as one-dimensional vectors (e.g. longitudes), two-dimensional arrays or matrices (raster “slices”), or multi-dimensional arrays (raster “bricks”). In such data strucures, the coordinate values for each grid point are implicit, inferred from the marginal values of, for example, longitude, latitude and time. In contrast, in R, the principal data structure for a variable is the data frame. In the kinds of data sets usually stored as NetCDF files, each row in the data frame will contain the data for an individual grid point, with each column representing a particular variable, including explicit values longitude and latitude (and perhaps time). In the example CRU data set considered here, the variables would consist of longitude, latitude and 12 columns of long-term means for each month, with the full data set thus consisting 'r nlon' by 'r nlat' rows and 'r nt+2' columns.

This stucture can be demonstrated by selecting a single slice from the temperature “brick”, turning it into a dataframe with three variables and 'r nlon' by 'r nlat' rows, and writing it out as a .csv file.

```{r}
m <- 1
tmp.slice <- tmp.array[, , m]
```

The dimensions of tmp.slice, e.g. 720, 360, can be verified using the dim() function.

A quick look (map) at the extracted slice of data can be gotten using the image() function.

```{r}
image(lon, lat, tmp.slice, col = rev(brewer.pal(10, "RdBu")))
```

A better map can be obtained using the levelplot() function from the lattice package. The expand.grid() function is used to create a set of 720 by 360 pairs of latitude and longitude values (with latitudes varying most rapidly), one for each element in the tmp.slice array. Specific values of the cutpoints of temperature categories are defined to cover the range of temperature.

```{r}
grid <- expand.grid(lon = lon, lat = lat)
cutpts <- c(-50, -40, -30, -20, -10, 0, 10, 20, 30, 40, 50)
levelplot(tmp.slice ~ lon * lat, data = grid, at = cutpts, cuts = 11, pretty = T, 
    col.regions = (rev(brewer.pal(10, "RdBu"))))

```

To create a data frame, the expand.grid() function is used to create the 259200 pairs of values of longtiude and latitude, and the as.vector() function is used to “unstack” the slice of data into a long vector, the length of which can be verified using the length() function.

```{r}
lonlat <- expand.grid(lon, lat)

tmp.vec <- as.vector(tmp.slice)
length(tmp.vec)
```

The data.frame() and cbind() functions are used to assemble the columns of the data frame, which are assigned appropriate names using the names() function (on the left-hand side of assignment operator). The head() function, applied on top of the na.omit() function lists the first rows of values without NAs:

```{r}
tmp.df01 <- data.frame(cbind(lonlat, tmp.vec))
names(tmp.df01) <- c("lon", "lat", paste(dname, as.character(m), sep = "_"))
head(na.omit(tmp.df01), 20)
```

Finally the data frame is written out to the working directory as a .csv file, using na.omit() again to drop the observations with missing data (i.e. ocean points and Antarctica).

```{r}
csvfile <- "cru_tmp_1.csv"
write.table(na.omit(tmp.df01), csvfile, row.names = FALSE, sep = ",")
```


### Convert the whole array to a data frame, and calculate MTWA, MTCO and the annual mean

Convert the nlon by nlat by nt array into a nlon by nlat by nt matrix. (This will work if the NetCDF data set was written as a CF-compliant data set, with arrays dimensioned as in Fortran, as nlon x nlat x nt arrays) First, create a long vector tmp.vec.long using the as.vector() reshaping function, and verify its length, which should be 3110400.

```{r}
tmp.vec.long <- as.vector(tmp.array)
length(tmp.vec.long)
```

Then reshape that vector into a 259200 by 12 matrix using the matrix() function, and verify its dimensions, which should be 259200 by 12.

```{r}
tmp.mat <- matrix(tmp.vec.long, nrow = nlon * nlat, ncol = nt)
dim(tmp.mat)
```

```{r}
head(na.omit(tmp.mat))
```

Create the second data frame from the tmp.mat matrix.
```{r}
lonlat <- expand.grid(lon, lat)
tmp.df02 <- data.frame(cbind(lonlat, tmp.mat))
names(tmp.df02) <- c("lon", "lat", "tmpJan", "tmpFeb", "tmpMar", "tmpApr", "tmpMay", 
    "tmpJun", "tmpJul", "tmpAug", "tmpSep", "tmpOct", "tmpNov", "tmpDec")
options(width = 110)
head(na.omit(tmp.df02, 20))

```

Get annual mean, mtwa and mtco values and add them the second data frame.
```{r}
tmp.df02$mtwa <- apply(tmp.df02[3:14], 1, max)  # mtwa
tmp.df02$mtco <- apply(tmp.df02[3:14], 1, min)  # mtco
tmp.df02$mat  <- apply(tmp.df02[3:14], 1, mean)  # annual (i.e. row) means

head(na.omit(tmp.df02))
```


```{r}
dim(na.omit(tmp.df02))
```

Write the second data frame out as a .csv file, dropping NAs.
```{r}
csvfile <- "cru_tmp_2.csv"
write.table(na.omit(tmp.df02), csvfile, row.names = FALSE, sep = ",")
```

Create a third data frame, with only non-missing values. This will be used later to demonstrate how to convert a “short” data frame into full matrix or array for writing out as a NetCDF file.

```{r}
tmp.df03 <- na.omit(tmp.df02)
head(tmp.df03)

```














------------------------------------------------------------------------

## Working with netcdf
Source: https://www.image.ucar.edu/GSP/Software/Netcdf/


### Simple example
Obtain the (binary) netCDF file: example.nc   [22kb -- tiny]. Most netCDF files are substantially more complicated than this simple example. 


```{r}
# Reading a netCDF file into R
library(ncdf4)
ex.nc = nc_open("./inst/extdata/example.nc")
```


This 'ex.nc' object has the information about the netCDF file example.nc but it does not contain the data! Retrieving various subsets of the data is done in separate steps. From within R you can get some information about this fil

```{r}
print(ex.nc)
```

These data consists of an 87X61 matrix of the variable 'Elevation' and the coordinate variables associated with the 2 dimensions: SN ( south - north axis ) and EW ( east-west axis). The elevations are from the R data set volcano. To retrieve the relevant variables and to make a surface plot:

```{r}
y = ncvar_get( ex.nc, "SN")          # coordinate variable
x = ncvar_get( ex.nc, "EW")          # coordinate variable
z = ncvar_get( ex.nc, "Elevation")   # variable

# image plot of terrain cribbed from help(volcano)
filled.contour(x,y,z, color = terrain.colors, asp = 1)
```

Here are some examples of extracting only part of the variable. It would be wise to assume you will not be able to read the entire variable into R and then subset. The hottest topic in the netCDF user community right now is "large file" support. In the GCM community, a "large file" is over 2GB, anything less that that is "just a file" ...

```{r}
z1 = ncvar_get( ex.nc, "Elevation", start=c(11,26), count=c( 5,5))
z1
```

```{r}
z2 <- ncvar_get( ex.nc, "Elevation", start=c(11,1), count=c( 5,-1))
z2
```

### Volcano: Creating a netCDF file from within R
Large projects create netCDF files using the low-level Unidata library routines. However, there are also functions for creating netCDF files within R. The following code creates the example.nc file used above. The reader should also refer to the help on put.var.ncdf from the ncdf R package for a good set of examples of creating multiple arrays.

```{r}
library(ncdf4)
data(volcano)

# put the data in a handy form 
z = 10 * volcano         # matrix of elevations
x = 100* (1:nrow(z))   # meter spacing (S to N)
y = 100* (1:ncol(z))   # meter spacing (E to W)
```

```{r}
# define the netcdf coordinate variables -- note these have values!

dim1 = ncdim_def( "EW","meters", as.double(x))
dim2 = ncdim_def( "SN","meters", as.double(y))

```


```{r}
# define the EMPTY (elevation) netcdf variable

varz = ncdf4::ncvar_def("Elevation","meters", list(dim1,dim2), -1, 
          longname="The Classic R New Zealand Volcano")
```


```{r}
# associate the netcdf variable with a netcdf file   
# put the variable into the file, and
# close

nc.ex = ncdf4::nc_create( "example.nc", varz )
ncdf4::ncvar_put(nc.ex, varz, z)
ncdf4::nc_close(nc.ex)

```


### More complicated access of multidimensional arrays and time variables

Obtain the netCDF file: Daily_b06_45.nc   [193kb -- still tiny].
https://www.image.ucar.edu/GSP/Software/Netcdf/Daily_b06_45.nc

```{r}
library(fields)
library(ncdf4)
library(chron)
```

```{r}
# This dataset happens to be the control experiment
control = nc_open("./inst/extdata/Daily_b06_45.nc", write=FALSE, readunlim=FALSE)
```

```{r fig.asp=1}
cat(paste(control$filename,"has",control$nvars,"variables"), fill=TRUE)

lonmat  = ncvar_get(nc=control,varid="longitude")   # reads entire matrix
latmat  = ncvar_get(nc=control,varid="latitude")    # ditto
timearr = ncvar_get(nc=control,varid="time")        # reads entire time array

plot( lonmat, latmat, main='The (MM5) grid locations')
US( add=T )
```

### Station Data

Obtain the netCDF file: [STN_050258.nc](https://www.image.ucar.edu/GSP/Software/Netcdf/STN_050258.nc)  [28kb -- miniscule]. PLEASE dump the header of this file! This is a 'real world' file. For the purpose of demonstration, I will assume you've done it and know there are the following variables:

```{r}
station = nc_open(filename = "./inst/extdata/STN_050258.nc", write=FALSE, readunlim=FALSE)

cat(paste(station$filename,"has",station$nvars,"variables"), fill=TRUE)

lons    = ncvar_get(nc = station, varid = "longitude")   # reads entire coordinate variable
lats    = ncvar_get(nc = station, varid = "latitude")    # kinda boring, since the station
elev    = ncvar_get(nc = station, varid = "elevation")   # didn't move. They usually do.
timearr = ncvar_get(nc = station, varid = "time")        # reads entire time array
prcp    = ncvar_get(nc = station, varid = "PRCP")        # reads entire precip array
tmin    = ncvar_get(nc = station, varid = "TMIN")
tmax    = ncvar_get(nc = station, varid = "TMAX")
tobs    = ncvar_get(nc = station, varid = "TOBS")
snow    = ncvar_get(nc = station, varid = "SNOW")

```

```{r}

# plot 'em up
#set.panel(5,1)
plot( timearr, snow, main='SNOW')
plot( timearr, prcp, main='PRCP')
plot( timearr, tmin, main='TMIN')
plot( timearr, tmax, main='TMAX')
plot( timearr, tobs, main='TOBS')

# note that there are many more observations of snow and precip than temperature.
# The unobserved temperature data must be coded as 'missing' to use the same time
# coordinate variable. 
```

### plotting with ggplot
http://stackoverflow.com/a/38039115
```{r}
library(ncdf4)
library(ggplot2)
library(dplyr)


# ref origin for this one is diff than 
time <- as.Date(timearr, origin="1601-01-01")

data_frame(month = time,
           var = snow) %>% 
  ggplot(aes(month, var)) +
  geom_line()

```







## NetCDF and the raster package
Source: http://geog.uoregon.edu/GeogR/topics/netcdf-to-raster.html

The raster package has the capability of reading and writing netCDF files. There are several issues that could arise in such transformations (i.e. from the netCDF format to the raster format) related to such things as the indexing of grid-cell locations: netCDF coordinates refer to the center of grid cells, while raster coordinates refer to cell corners.

In practice, the raster package seems to “do the right thing” in reading and writing netCDF, as can be demonstrated using a “toy” data set. In the examples below, a simple netCDF data set will be generated and written out using the ncdf4 package. Then that netCDF data set will be read in as a raster “layer” and plotted, and finally the raster layer will be written again as a netCDF file. As can be seen, the coordinate systems are appropriately adjusted going back and forth between netCDF and the raster “native” format.

Generate and write a simple netCDF file

Generate a small nlon = 8, nlat = 4, 2-d netCDF data set, filled with normally distributed random numbers

```{r}
library(ncdf4)

# create a small netCDF file, save, and read back in using 
# raster and rasterVis generate lons and lats
nlon <- 8; nlat <- 4
dlon <- 360.0/nlon; dlat <- 180.0/nlat
lon <- seq(-180.0+(dlon/2),+180.0-(dlon/2),by=dlon)
lon
```

```{r}
lat <- seq(-90.0+(dlat/2),+90.0-(dlat/2),by=dlat)
lat
```

```{r}
# generate some data
set.seed(10) # for reproducibility
tmp <- rnorm(nlon*nlat)
tmat <- array(tmp, dim = c(nlon, nlat))
dim(tmat)
```

```{r}
# define dimensions
londim <- ncdim_def("lon", "degrees_east", as.double(lon))
latdim <- ncdim_def("lat", "degrees_north", as.double(lat))

# define variables
varname="tmp"
units="z-scores"
dlname <- "test variable -- original"
fillvalue <- 1e20
tmp.def <- ncvar_def(varname, units, list(londim, latdim), fillvalue, 
                     dlname, prec = "single")
```


As can be seen, the longitudes run from -157.5 to +157.5, while the latitudes run from -67.5 to +67.5, and they define the centers of the netCDF grid cells.

Write the generated data to a netCDF file.

```{r}
# create a netCDF file 
ncfname <- "./inst/extdata/test-netCDF-file.nc"
ncout <- nc_create(ncfname, list(tmp.def), force_v4 = TRUE)

# put the array
ncvar_put(ncout, tmp.def, tmat)

# put additional attributes into dimension and data variables
ncatt_put(ncout, "lon", "axis", "X")  
ncatt_put(ncout, "lat", "axis", "Y")

# add global attributes
title <- "small example netCDF file"
ncatt_put(ncout, 0, "title", title)

# close the file, writing data to disk
nc_close(ncout)
```


###Read a netCDF file as a raster layer

Now read the netCDF data set back in as a raster object

```{r}
library(raster)
library(rasterVis)
library(maptools)
library(maps)
```
```{r}
# read the netCDF file as a raster layer
tmpin <- raster(ncfname)
tmpin
```

Listing the object provides its internal raster attributes, while the print() function provides the characteristics of the source netCDF file.

```{r}
print(tmpin)
```

The data can be mapped using the rasterVis version of the levelplot() function, with continental outlines from the maps package overlain.

```{r}
# map the data
world.outlines <- map("world", plot=FALSE)
world.outlines.sp <- map2SpatialLines(world.outlines, proj4string = CRS("+proj=longlat"))

mapTheme <- rasterTheme(region = rev(brewer.pal(10, "RdBu")))
cutpts <- c(-2.5, -2.0, -1.5, -1, -0.5, 0, 0.5, 1.0, 1.5, 2.0, 2.5)
plt <- levelplot(tmpin, margin = F, at=cutpts, cuts=11, pretty=TRUE, par.settings = mapTheme,
  main="test variable -- as raster layer")
plt + layer(sp.lines(world.outlines.sp, col = "black", lwd = 0.5))
```


```{r}
# write the raster layer (tmpin)
outfile <- "./inst/extdata/test_raster.nc"
crs(tmpin) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0" 
writeRaster(tmpin, outfile, overwrite=TRUE, format="CDF", varname="tmp", varunit="z-scores", 
  longname="test variable -- raster layer to netCDF", xname="lon", yname="lat")
```

### PanoplyJ
Open the file `test_raster.nc` with PanoplyJ in Linux or other OS. 
Create a plot of the georeferenced variable `tmp`




NetCDF is a widely used format for exchanging or distributing climate data, and has also been adopted in other fields, particularly in bioinformatics, and in other disciplines where large multidimensional arrays of data are generated. NetCDF files are self-describing, in the sense that they contain metadata that describes what is contained in a file, such as the latitude and longitude layout of the grid, the names and units of variables in the data set, and "attributes" that describe things like missing value codes, or offsets and scale factors that may have been used to compress the data. NetCDF files are also machine-independent because can be transferred among servers and computers that are running differing operating systems, without having to convert the files in some way. Originally developed for storing and distributing climate data, such as those generated by climate simulation or reanalysis models, the format and protocols can be used for other gridded data sets. NetCDF libraries are developed and maintained by Unidata http://www.unidata.ucar.edu/software/netcdf/ and easy-to-use applications for producing simple visualizations of NetCDF files exist, such as Panoply, http://www.giss.nasa.gov/tools/panoply/.

R has the capability of reading and writing (and hence analyzing) netCDF files, using the `ncdf4` package provided by David Pierce, and through other packages like `raster` and `RNetCDF`. The ncdf4.helpers package provides some additional tools.


--------------------------------------------------

## How to read and plot netCDF files with R

### Download netCDF
Selecte variable and year to download the netCDF file in the working directory.
URL: ftp://ftp.cdc.noaa.gov/Datasets/ncep.reanalysis/pressure/air.2015.nc

```{r}
# Select: variable and year
var='air'
year=2015
 
# Download netCDF file
url=paste('ftp://ftp.cdc.noaa.gov/Datasets/ncep.reanalysis/pressure/',var,'.',year,'.nc', sep='')
dfile=paste(var,'.',year,'.nc', sep='')
download.file(url, destfile=dfile)

```

### Read netCDF and get selection

To open and read netCDF files the R package ncdf is used.







```{r}
# Define our function
process_nc <- function(files){
    # iterate through the nc
    for (i in 1:length(files)){
        # open a conneciton to the ith nc file
        # nc_tmp <- nc_open(paste0("data/", files[i]))
      nc_tmp <- nc_open(paste0("./", files[i]))
        # store values from variables and atributes
        nc_chla <- ncvar_get(nc_tmp, attributes(nc_tmp$var)$names[1])
        nc_lat <- ncvar_get(nc_tmp, attributes(nc_tmp$dim)$names[1])
        nc_lon <- ncvar_get(nc_tmp, attributes(nc_tmp$dim)$names[2])
        nc_atts <- ncatt_get(nc_tmp, 0)
        nc_start_date <- as.Date(nc_atts$period_start_day, format = "%Y%m%d", tz = "UTC")
        # close the connection sice were finished
        nc_close(nc_tmp)
        # set the dimension names and values of your matrix to the appropriate latitude and longitude values
        dimnames(nc_chla) <- list(lon=nc_lon, lat=nc_lat)

        # I'm choosing to store all the data in long format.
        # depending on your workflow you can make different choices here...
        # Your variable may get unmanageably large here
        # if you have high spatial and temporal resolution nc data.
        tmp_chl_df <- melt(nc_chla, value.name = "chla")
        tmp_chl_df$date_start <- nc_start_date

        # set the name of my new variable and bind the new data to it
        if (exists("chla_data_monthly")){
            chla_data_monthly <- bind_rows(chla_data_monthly, tmp_chl_df)
        }else{
            chla_data_monthly <- tmp_chl_df
        }
        # tidy up, not sure if necesarry really, but neater
        rm(nc_chla, nc_lat, nc_lon, nc_tmp, nc_atts, nc_start_date, tmp_chl_df)
    }

    return(chla_data_monthly)
}


data <- process_nc(flist)
```

