---
title: "netcdf versus HDF5"
output: html_notebook
---


## Working with netcdf
Source: https://www.image.ucar.edu/GSP/Software/Netcdf/

Obtain the (binary) netCDF file: example.nc   [22kb -- tiny]. Most netCDF files are substantially more complicated than this simple example. 


Reading a netCDF file into R
```{r}
library(ncdf4)
ex.nc = nc_open("example.nc")
```


This 'ex.nc' object has the information about the netCDF file example.nc but it does not contain the data! Retrieving various subsets of the data is done in separate steps. From within R you can get some information about this fil

```{r}
print(ex.nc)
```

These data consists of an 87X61 matrix of the variable 'Elevation' and the coordinate variables associated with the 2 dimensions: SN ( south - north axis ) and EW ( east-west axis). The elevations are from the R data set volcano. To retrieve the relevant variables and to make a surface plot:

```{r}
y = ncvar_get( ex.nc, "SN")          # coordinate variable
x = ncvar_get( ex.nc, "EW")          # coordinate variable
z = ncvar_get( ex.nc, "Elevation")   # variable

# image plot of terrain cribbed from help(volcano)
filled.contour(x,y,z, color = terrain.colors, asp = 1)
```

Here are some examples of extracting only part of the variable. It would be wise to assume you will not be able to read the entire variable into R and then subset. The hottest topic in the netCDF user community right now is "large file" support. In the GCM community, a "large file" is over 2GB, anything less that that is "just a file" ...

```{r}
z1 = ncvar_get( ex.nc, "Elevation", start=c(11,26), count=c( 5,5))
z1
```

```{r}
z2 <- ncvar_get( ex.nc, "Elevation", start=c(11,1), count=c( 5,-1))
z2
```

## Creating a netCDF file from within R
Large projects create netCDF files using the low-level Unidata library routines. However, there are also functions for creating netCDF files within R. The following code creates the example.nc file used above. The reader should also refer to the help on put.var.ncdf from the ncdf R package for a good set of examples of creating multiple arrays.

```{r}
library(ncdf4)
data(volcano)

# put the data in a handy form 
z = 10 * volcano         # matrix of elevations
x = 100* (1:nrow(z))   # meter spacing (S to N)
y = 100* (1:ncol(z))   # meter spacing (E to W)
```

```{r}
# define the netcdf coordinate variables -- note these have values!

dim1 = ncdim_def( "EW","meters", as.double(x))
dim2 = ncdim_def( "SN","meters", as.double(y))

```


```{r}
# define the EMPTY (elevation) netcdf variable

varz = ncdf4::ncvar_def("Elevation","meters", list(dim1,dim2), -1, 
          longname="The Classic R New Zealand Volcano")
```


```{r}
# associate the netcdf variable with a netcdf file   
# put the variable into the file, and
# close

nc.ex = ncdf4::nc_create( "example.nc", varz )
ncdf4::ncvar_put(nc.ex, varz, z)
ncdf4::nc_close(nc.ex)

```


## More complicated access of multidimensional arrays and time variables

Obtain the netCDF file: Daily_b06_45.nc   [193kb -- still tiny].
https://www.image.ucar.edu/GSP/Software/Netcdf/Daily_b06_45.nc

```{r}
library(fields)
library(ncdf4)
library(chron)
```

```{r}
# This dataset happens to be the control experiment
control = nc_open("Daily_b06_45.nc", write=FALSE, readunlim=FALSE)
```

```{r fig.asp=1}
cat(paste(control$filename,"has",control$nvars,"variables"), fill=TRUE)

lonmat  = ncvar_get(nc=control,varid="longitude")   # reads entire matrix
latmat  = ncvar_get(nc=control,varid="latitude")    # ditto
timearr = ncvar_get(nc=control,varid="time")        # reads entire time array

plot( lonmat, latmat, main='The (MM5) grid locations')
US( add=T )
```


## RNetCDF

RNetCDF is an R interface to the NetCDF C-library. Most of the functions provided by version 3 of
NetCDF are accessible through RNetCDF in a way that allows users to build functions easily for their
specific needs. Some higher-level features for frequently used operations are provided by RNetCDF,
such as automatic support for missing values and packed variables and the ability to read all variables
into an R list. Calendar conversion functions from Unidata’s UDUNITS library are also included in
this package to simplify the handling of time variables in NetCDF datasets.

As an example, assume we have a climatological dataset with daily temperature measurements at five
imaginary weather stations. Three variables are defined: time (as date with year, month, day, hour,
minute, second), temperature and station name:

```{r}
library(RNetCDF)

mytime <- matrix(nrow=2, ncol=6)
mytime[1,] <- c(2012, 06, 01, 12, 00, 00)
mytime[2,] <- c(2012, 06, 02, 12, 00, 00)
mytime_units <- "days since 1970-01-01 00:00:00"

mytemperature <- matrix(c(1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, NA, NA, 9.9),
ncol=2, nrow=5)

myname <- c("Alfa", "Bravo", "Charlie", "Delta", "Echo")

```


When creating the NetCDF dataset, the organisation of the data should be known in advance.
While changes to the structure of the file are possible, they may involve significant reorganisation of
data within the file. To allow for expansion of a file with new data, it is possible to declare a single
dimension with “unlimited” size. As a first step in our example, the file has to be created and all
dimensions and variables need to be defined:

```{r}
nc <- create.nc("foo.nc")

dim.def.nc(nc, "station", 5)
dim.def.nc(nc, "time", unlim=TRUE)
dim.def.nc(nc, "max_string_length", 32)

var.def.nc(nc, "time", "NC_INT", "time")
var.def.nc(nc, "temperature", "NC_DOUBLE", c("station", "time"))
var.def.nc(nc, "name", "NC_CHAR", c("max_string_length", "station"))
```

At this point, missing values (NA) cannot be written and the time axis is not yet defined. For
this purpose, attributes have to be set and the time matrix needs to be converted into a vector with a
reference time (as defined already above):
```{r}
att.put.nc(nc, "temperature", "_FillValue", "NC_DOUBLE", -99999.9)
att.put.nc(nc, "time", "units", "NC_CHAR", mytime_units)
```

```{r}
mytime_ut <- utinvcal.nc(mytime_units, mytime)
```


Now the variable data can be written. To ensure that the data are written to the file and not
buffered in memory, the file should be closed when all operations are complete:
```{r}
var.put.nc(nc, "name", myname)
var.put.nc(nc, "time", mytime_ut)
var.put.nc(nc, "temperature", mytemperature)
close.nc(nc)
```

If more data is to be added to the file in the same R session, the file may be
left open, but to avoid loss of data, it may be desirable to force the flushing
of buffers to disk using the function sync.nc() at critical stages of a
calculation.

In our example, the NetCDF dataset is written to disk with the absolute minimum
of required attributes. However, such a dataset is not really self-describing
and would not conform with any conventions. Therefore, further attributes would
need to be set. According to the CF-standard, a variable should have at least
the attributes ‘long_name’ (e.g., ‘measured air temperature’), ‘units’ (e.g.,
‘degrees_celsius’), and ‘standard_name’ (e.g., ‘air_temperature’) (the latter is
not needed for the time coordinate variable). The possible values for
‘standard_name’ can be found in the CF conventions document. CF also requests
the indication of six global attributes, namely ‘title’, ‘history’, 
‘institution’, ‘source’, ‘comment’, and ‘references’. Although not mandatory, it
is recommended that NetCDF datasets comply with the CF or any other standard, so
that the contents of a file are described unambiguously. If these rules are
followed, NetCDF datasets can be explored and processed using general-purpose
software, and they can be distributed or archived without any risk that the data
in a file could become separated from its description.


## Reading an existing NetCDF dataset
To show the contents of a NetCDF dataset, it must first be opened with the
open.nc() function. The print.nc() function displays an overview of the dataset
on standard output, giving the dimension definitions, variable definitions
including their attributes, and the contents of the global attributes. For the
example dataset created earlier, an overview can be displayed as follows:
```{r}
nc <- open.nc("foo.nc")
print.nc(nc)
```

```{r}
mytemp <- var.get.nc(nc, "temperature", start=c(NA,2), count=c(NA,1))
mytemp
```

The easiest way to read the contents of all variables from a NetCDF dataset is
by using the function read.nc(), which is available in RNetCDF version 1.6 or
later. This function returns a list with the variables as named elements.
Although this function has no equivalent in the NetCDF C-interface, it has been
added to RNetCDF to simplify a common operation. For example, the contents of
all variables can be read from our example dataset and the ‘temperature’
variable copied to another variable using the following commands:

```{r}
nc_data <- read.nc(nc)
mytemp <- nc_data$temperature
```

Attributes can be read from variables that are identified by name or number, and global attributes
can be read using the special variable name ‘NC_GLOBAL’. For example, conversion of relative times
into calendar times requires the ‘units’ attribute from the ‘time’ variable, which may be read using
the att.get.nc() function:

```{r}
time_units <- att.get.nc(nc, "time", "units")
time_units
```

For example, the names of all dimensions in a NetCDF dataset can be determined
as shown below. Note that NetCDF dimensions can be referenced by integers that
are sequential from 0; the same applies to variables and attributes.
```{r}
ndims <- file.inq.nc(nc)$ndims
dimnames <- character(ndims)

for(i in seq_len(ndims)) {
  dimnames[i] <- dim.inq.nc(nc, i-1)$name
}
```

