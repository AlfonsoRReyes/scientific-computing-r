---
title: "R Notebook"
output: html_notebook
---

### 1.4.1 Traditional programming
Let’s take an example and compare traditional programming with object programming.
The BMI, Body Mass Index, is a measurement of thinness or obesity. Is is calculated by
dividing the weight (in kilos) by the square size (in centimeters). Then, one concludes:

* 20 < BMI < 25: Everything is fine
* 25 < BMI < 30: Teddy bear
* 30 < BMI < 40: Comfortable Teddy bear
* 40 < BMI: Huge Teddy bear, with double softness effect, but who should go to see
a doctor very quickly...
* 18 < BMI < 20: Barbie
* 16 < BMI < 18: Barbie model
* BMI < 16: Barbie skeleton, same diagnosis as the huge Teddy bear, be careful...
So we wish to calculate the BMI. In traditional programming, nothing simpler:



### 1.4.2 Object programming
In object language, the method is different. It is necessary to begin by defining an object
BMI which will contain two values, weight and size. Then, it is necessary to define the
function show which will indicate the BMI


```{r}
### Definition of an object BMI
setClass("BMI", representation(weight="numeric", size="numeric"))

setMethod("show", "BMI",
 function(object){cat("BMI=",object@weight/(object@size^2)," \n ")}
 )

```

```{r}
### Creation of an object for me, and posting of my BMI
(myBMI <- new("BMI",weight=85,size=1.84))

```

```{r}
### Creation of an object for her, and posting of her BMI
(herBMI <- new("BMI",weight=62,size=1.60))

```

When initialization is correct (a problem which was also occurs in the traditional
programming), no more error will be possible. Here lays the strength of object: the
design of the program prevents from a certain number of bugs.

**Type**: the object also protects from type errors. A type errors consist in using a type
where another type would be necessary. For example, adding a characterto a numeric.
This is more or less like adding apples and kilometers instead of adding apples and
apples. Oriented object programmation prevent that:

```{r}
### traditional programming, no type
(weight <- "Hello")

```

```{r}
new("BMI",weight="Hello",size=1.84)
```

**Validity checking**: Object enables to use “coherence inspectors” to check if the object
follow some rules. For example, one might want to prohibit negative sizes:

```{r}
### Traditional programming, without control
(SizeMe <- -1.84)

```

```{r}
### Object programming, control
setValidity("BMI", function(object) { 
    if(object@size<0) { 
        return("negative Size") 
        } else { 
        return(TRUE)
}} )
```

```{r}
new("BMI",weight=85,size=-1.84)

```

**Inheritance**: object programming enables to define one object like Inherit from the
properties of another object, thus becoming its son. The son object thus profits from all
that exists for the father object. For example, one wishes to refine a little our diagnoses
according to the sex of the person. We will thus define a new object, BMIplus, which
will contain three values: weight, size and sex. The first two variables are the same
ones as that of the object BMI. We will thus define the object BMIplus as heir of the
object BMI. It will thus be able to profit from the function show such as we defined it for BMI and it will do so without any additional work, since BMIplus inherits BMI:

```{r}
### Definition of the heir
setClass("BMIplus",representation(sex="character"),contains="BMI")

```


```{r}
he <- new("BMIplus",size=1.76,weight=84,sex="Male")
### Posting which uses what was defined for "BMI"
he

```

The power of this characteristic will appear more clearly in section 42.

**Encapsulation**: finally, object programming enables to define all the tools concerning
an object and to lock them up in blocks, without having to look after them anymore.
That is called encapsulation. Cars provide a good example of encapsulation: once the
hood closed, one does not need to know anymore about the details of the mechanics
to drive. Similarly, once the object finished and closed, a user does not have to worry
about its working procedure. Even better, concerning the cars, it is not possible to be
mistaken and to put gasoline in the radiator since the radiator is not accessible anymore.
In the same way, encapsulation enables to protect what must be protected, and to give
access only to what is not at risk.

## Basis of object programming

```{r}
setClass(Class="Trajectories",
 representation=representation(
 times = "numeric",
 traj = "matrix"
 ) )

```

## 4.2 Default constructor

```{r}
new(Class="Trajectories")
```

As you can note, the result is not easy to read... It will be important to define a
method to improve it. We’ll deal with that in the section 5.2 page 20.
It is possible to define an object by specifying the values of its slots (all of them, or
partly). We must each time specify it name of the concerning field:

```{r}
new(Class="Trajectories",times=c(1,3,4))
```


```{r}
new(Class="Trajectories",times=c(1,3),traj=matrix(1:4,ncol=2))
```

An object can be stored in a variable like any other value of R. To illustrate our
statements, we are going to build up a small example. Three hospitals take part to the
study. The Piti´e Salpˆetriere (which has not yet returned its data file, shame on them!), Cochin and Saint-Anne:

```{r}
trajPitie <- new(Class="Trajectories")
trajCochin <- new(Class= "Trajectories",
                 times=c(1,3,4,5),
                 traj=rbind (
                 c(15,15.1, 15.2, 15.2),
                 c(16,15.9, 16,16.4),
                 c(15.2, NA, 15.3, 15.3),
                 c(15.7, 15.6, 15.8, 16)
 ))

```


```{r}
trajStAnne <- new(Class= "Trajectories",
             times=c(1: 10, (6: 16) *2),
             traj=rbind(
                matrix (seq (16,19, length=21), ncol=21, nrow=50, byrow=TRUE),
                matrix (seq (15.8, 18, length=21), ncol=21, nrow=30, byrow=TRUE)
             )+rnorm (21*80,0,0.2)
 )

```


## Reach a slot

```{r}
trajCochin@times
```

```{r}
trajCochin@times <- c(1,2,4,5)
trajCochin
```

As we will see thereafter, the use of the @ should be avoided. Indeed, it does not
call upon the methods of checking. The use that we present here (posting of a field, and
even worse, assignment of a value to a field) should thus be proscribed in most cases.

It is also possible to use the functions attr or attributes, but it is even
worse: if one makes a simple typographic error, one modifies the structure of
the object. And that is very very very bad!

## 4.4 Default values
```{r}
setClass(Class = "TrajectoriesBis", 
         representation=representation(
             time = "numeric",
             traj = "matrix"
         ),
         prototype=prototype(
            time = 1,
            traj = matrix (0)
 ) )
```



## The empty object

```{r}
identical(numeric(),integer())
```


## 4.7 to see an object

```{r}
slotNames("Trajectories")
```

```{r}
getSlots ("Trajectories")
```

```{r}
getClass ("Trajectories")
```


## SetMethod

```{r}
setMethod(f= "plot",
     signature= "Trajectories",
     definition=function (X,y,...){
     matplot(x@times,t(x@traj),xaxt="n",type="l",ylab= "",xlab="", pch=1)
     axis(1,at=x@times)
     }
     )
```

```{r}
setMethod ("print","Trajectories",
 function(x,...){
 cat("*** Class Trajectories, method Print *** \n")
 cat("* Times ="); print (x@times)
 cat("* Traj = \n"); print (x@traj)
 cat("******* End Print (trajectories) ******* \n")
 }
 )

```

```{r}
print(trajCochin)
```

For Cochin, the result is correct. For Saint-Anne, print will display too much
information. So we need a second method.
show is the default method used to show an object when its name is write in the
console. We thus define it by taking into account the size of the object: if there are too
many trajectories, show post only part of them.


```{r}
setMethod("show","Trajectories",
 function(object){
 cat("*** Class Trajectories, method Show *** \n")
 cat("* Times ="); print(object@times)
 nrowShow <- min(10,nrow(object@traj))
 ncolShow <- min(10,ncol(object@traj))
 cat("* Traj (limited to a matrix 10x10) = \n")
 print(formatC(object@traj[1:nrowShow,1:ncolShow]),quote=FALSE)
 cat("******* End Show (trajectories) ******* \n")
 }
 )
```

```{r}
trajStAnne
```


A small problem must still be regulated. We saw in section 4.6 page 17 that new
should be usable without any argument. However, it is no longer true:


```{r}
new("Trajectories")
```

Indeed, `new` creates an object, then display it using `show`. In the case of new without
any argument, the empty object is send to show. However, show as we conceived it
cannot treat the empty object.
More generally, all our methods must take into account the fact that they may have
to deal with the empty object:

```{r}
setMethod("show","Trajectories", function(object){
     cat("*** Class Trajectories, method Show *** \n")
     cat("* Times = "); print (object@times)
     nrowShow <- min(10,nrow(object@traj))
     ncolShow <- min(10,ncol(object@traj))
     cat("* Traj (limited to a matrix 10x10) = \n")
     if(length(object@traj)!=0){
        print(formatC(object@traj[1:nrowShow,1:ncolShow]),quote=FALSE)
     } else{}
        cat("******* End Show (trajectories) ******* \n")
 }
 )
```

